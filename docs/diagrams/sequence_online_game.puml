@startuml sequence_online_game

title Online Multiplayer Game - Sequence Diagram

skinparam sequenceArrowThickness 2
skinparam roundcorner 10
skinparam maxmessagesize 200

actor "Player 1\n(Red)" as P1
participant "GUI Client 1" as C1
participant "Flask-SocketIO\nServer" as Server
database "PostgreSQL\nDatabase" as DB
participant "GUI Client 2" as C2
actor "Player 2\n(Yellow)" as P2

== Authentication Phase ==

P1 -> C1: Enter credentials
activate C1
C1 -> Server: POST /login\n{username, password}
activate Server
Server -> DB: Verify credentials
activate DB
DB --> Server: User data
deactivate DB
Server --> C1: 200 OK {user_id, rating}
deactivate Server

C1 -> Server: socket.connect()
activate Server
Server --> C1: Connected (SID assigned)
deactivate Server
deactivate C1

P2 -> C2: Enter credentials
activate C2
C2 -> Server: POST /login
activate Server
Server -> DB: Verify credentials
activate DB
DB --> Server: User data
deactivate DB
Server --> C2: 200 OK
deactivate Server

C2 -> Server: socket.connect()
activate Server
Server --> C2: Connected
deactivate Server
deactivate C2

== Game Creation Phase ==

P1 -> C1: Click "Create Game"
activate C1
C1 -> Server: emit('create_game', {user_id})
activate Server
Server -> Server: Generate room_id
Server -> DB: Create game record
activate DB
DB --> Server: OK
deactivate DB
Server --> C1: emit('game_created',\n{room_id, player_piece: RED})
Server -> Server: Join P1 to room
deactivate Server
C1 --> P1: Display "Waiting for opponent..."
deactivate C1

== Game Join Phase ==

P2 -> C2: Click room in lobby
activate C2
C2 -> Server: emit('join_game',\n{room_id, user_id})
activate Server
Server -> Server: Validate room exists
Server -> Server: Join P2 to room
Server -> DB: Update game status
activate DB
DB --> Server: OK
deactivate DB
Server --> C2: emit('game_joined',\n{room_id, player_piece: YELLOW})
Server --> C1: emit('game_start', {})
Server --> C2: emit('game_start', {})
deactivate Server
C2 --> P2: Display board
deactivate C2

== Gameplay Loop ==

loop Until game ends
    
    P1 -> C1: Click column 3
    activate C1
    C1 -> C1: Validate locally\n(column not full)
    C1 -> C1: Animate piece drop
    C1 -> Server: emit('make_move',\n{room_id, col:3, piece:RED})
    activate Server
    
    Server -> Server: Validate move\n(bitboard check)
    Server -> Server: Apply move to\nauthoritative state
    Server -> Server: Check win condition\n(8 bitwise ops)
    
    alt Win detected
        Server -> DB: Update results, ELO
        Server --> C1: emit('game_over',\n{winner: RED})
        Server --> C2: emit('game_over',\n{winner: RED})
    else No win
        Server --> C1: emit('move_made',\n{col:3, current:YELLOW})
        Server --> C2: emit('move_made',\n{col:3, current:YELLOW})
    end
    
    deactivate Server
    C2 -> C2: Animate opponent move
    C2 --> P2: Update board
    deactivate C1
    
    note over P1,P2: Turn passes to Player 2
    
    P2 -> C2: Click column 4
    activate C2
    C2 -> Server: emit('make_move',\n{room_id, col:4, piece:YELLOW})
    activate Server
    Server -> Server: Validate & apply
    Server --> C1: emit('move_made',\n{col:4, current:RED})
    Server --> C2: emit('move_made',\n{col:4, current:RED})
    deactivate Server
    C1 -> C1: Animate opponent move
    deactivate C2
    
end

== Game Over ==

Server --> C1: emit('game_over', {winner})
Server --> C2: emit('game_over', {winner})

note over Server,DB
  ELO calculation:
  Winner: +15 points
  Loser: -15 points
end note

@enduml
